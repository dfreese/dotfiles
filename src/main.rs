extern crate chrono;

enum FileType {
    // The file to which it links
    Link(std::path::PathBuf),
    File,
    DoesntExist,
    Other,
}

fn filetype(filename: &std::path::Path) -> FileType {
    if !filename.exists() {
        return FileType::DoesntExist;
    }
    if !filename.is_file() {
        return FileType::Other;
    }
    match filename.read_link() {
        Ok(x) => FileType::Link(x),
        _ => FileType::File,
    }
}

fn add_bak(filename: &std::path::PathBuf) -> std::path::PathBuf {
    match filename.extension() {
        Some(x) => filename.with_extension(format!("{}.bak", x.to_string_lossy())),
        None => filename.with_extension("bak"),
    }
}

fn vim_source_line(filename: &std::path::PathBuf) -> String {
    format!("source {}\n", filename.to_string_lossy())
}

fn vim_source_line_with_timestamp(filename: &std::path::PathBuf) -> String {
    format!(
        "\" autogenerated from dfreese/dotfiles at {}\nsource {}\n",
        chrono::Utc::now(),
        filename.to_string_lossy()
    )
}

fn file_contains(filename: &std::path::PathBuf, pattern: &String) -> std::io::Result<bool> {
    let contents = std::fs::read_to_string(filename)?;
    Ok(contents.contains(pattern))
}

fn confirm(prompt: String) -> std::io::Result<bool> {
    use std::io::{stdin, stdout, Write};

    let mut input = String::new();
    print!("{} (Y/n): ", prompt);
    stdout().flush()?;
    stdin().read_line(&mut input)?;
    let trimmed = input.trim().to_lowercase();

    Ok(trimmed.is_empty() || trimmed == "y")
}

fn update_link(
    x: &std::path::PathBuf,
    location: &std::path::PathBuf,
    target: &std::path::PathBuf,
) -> std::io::Result<()> {
    if *x == *target {
        println!(
            "{} already points to {}",
            location.display(),
            target.display()
        );
    } else {
        let prompt = format!(
            "{} points to {}.  Update it to {}?",
            location.display(),
            x.display(),
            target.display()
        );
        if confirm(prompt)? {
            std::fs::remove_file(location)?;
            std::os::unix::fs::symlink(target, location)?;
        }
    }
    Ok(())
}

fn handle_home_link(
    location: &std::path::PathBuf,
    target: &std::path::PathBuf,
) -> std::io::Result<()> {
    match filetype(&location) {
        FileType::Link(x) => {
            update_link(&x, &location, &target)?;
        }
        FileType::File => {
            let backup = add_bak(&location);
            let prompt = format!(
                "A file exists at {}.  Move it to {} and add a link to {}?",
                location.display(),
                backup.display(),
                target.display()
            );
            if confirm(prompt)? {
                std::fs::rename(&location, &backup)?;
                std::os::unix::fs::symlink(target, location)?;
            }
        }
        FileType::DoesntExist => {
            let prompt = format!(
                "Nothing exists at {}.  Link it to {}?",
                location.display(),
                target.display()
            );
            if confirm(prompt)? {
                std::os::unix::fs::symlink(target, location)?;
            }
        }
        FileType::Other => {
            println!(
                "No clue how to handle whatever exists at {}. Good luck",
                location.display()
            );
        }
    }
    Ok(())
}

fn update_vimrc(location: &std::path::PathBuf, target: &std::path::PathBuf) -> std::io::Result<()> {
    use std::io::Write;
    match filetype(&location) {
        FileType::Link(x) => {
            update_link(&x, &location, &target)?;
        }
        FileType::File => {
            let backup = add_bak(&location);
            if file_contains(&location, &vim_source_line(&target))? {
                println!(
                    "{} already sources {}",
                    location.display(),
                    target.display()
                );
                return Ok(());
            }
            let prompt = format!(
                "A file exists at {}.  Move it to {} and add a link to {}?",
                location.display(),
                backup.display(),
                target.display()
            );
            if confirm(prompt)? {
                std::fs::rename(&location, &backup)?;
                std::os::unix::fs::symlink(target, location)?;
                return Ok(());
            }
            let prompt = format!(
                "A file exists at {}.  Source {} within it?",
                location.display(),
                target.display()
            );
            if confirm(prompt)? {
                let mut file = std::fs::OpenOptions::new().append(true).open(&location)?;
                file.write_all(vim_source_line_with_timestamp(&target).as_bytes())?;
            }
        }
        FileType::DoesntExist => {
            let prompt = format!(
                "Nothing exists at {}.  Create it and source {}?",
                location.display(),
                target.display()
            );
            if confirm(prompt)? {
                let mut buffer = std::fs::File::create(&location)?;
                buffer.write_all(vim_source_line_with_timestamp(&target).as_bytes())?;
            }
        }
        FileType::Other => {
            println!(
                "No clue how to handle whatever exists at {}. Good luck",
                location.display()
            );
        }
    }
    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let home_var = std::env::var("HOME")?;
    let home = std::path::Path::new(&home_var);

    let path = std::env::current_dir()?;
    println!("The current directory is {}", path.display());

    let home_dir_symlinks = vec![
        ".gitconfig",
        ".clang-format",
        ".tmux.conf",
        ".ycm_extra_conf.py",
    ];
    for name in &home_dir_symlinks {
        handle_home_link(&home.join(name), &path.join(name))?;
    }

    update_vimrc(&home.join(".vimrc"), &path.join("importable.vim"))?;

    // TODO(dfreese): add handling for personal.bashrc
    // would require different handling of profile, bash_profile, and bashrc
    // that wouldn't be completely trivial.
    println!(
        "If you haven't already, make sure your .profile, .bash_profile, \
        or .bashrc sources {}",
        &path.join("personal.bashrc").display()
    );

    Ok(())
}
